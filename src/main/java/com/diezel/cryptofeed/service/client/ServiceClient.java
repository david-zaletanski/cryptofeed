package com.diezel.cryptofeed.service.client;

import com.diezel.cryptofeed.service.client.token.ClientTokenManager;
import com.diezel.cryptofeed.service.client.token.ClientTokenProvider;
import com.diezel.cryptofeed.service.client.token.DefaultTokenProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import javax.validation.constraints.NotNull;
import java.util.Arrays;

/**
 * A wrapper for the Spring RestTemplate that includes a number of utility methods that make calling REST
 * service endpoints (particularly ones requiring authentication) easier.
 *
 * @author dzale
 */
public class ServiceClient {

    private static final Logger log = LoggerFactory.getLogger(ServiceClient.class);

    // Used to actually make service calls
    protected RestTemplate restTemplate;

    // Handles providing valid JWT tokens
    protected ClientTokenManager tokenManager;

    public ServiceClient() {
        this.restTemplate = getDefaultRestTemplate();
        this.tokenManager = new ClientTokenManager(getDefaultTokenProvider());
    }

    public ServiceClient(ClientTokenProvider provider) {
        this.restTemplate = getDefaultRestTemplate();
        this.tokenManager = new ClientTokenManager(provider);
    }

    public <T> ResponseEntity<T> callEndpoint(ServiceEndpoint endpoint,
                                              ParameterizedTypeReference<T> responseClazz)
            throws ServiceClientException {
        return callEndpointAuthorizedImpl(endpoint, null, responseClazz, false, null);
    }

    public <T, R> ResponseEntity<T> callEndpoint(ServiceEndpoint endpoint,
                                                 R requestObject,
                                                 ParameterizedTypeReference<T> responseClazz)
            throws ServiceClientException {
        return callEndpointAuthorizedImpl(endpoint, requestObject, responseClazz, false, null);
    }

    public <T, R> ResponseEntity<T> callEndpoint(ServiceEndpoint endpoint,
                                                 R requestObject,
                                                 ParameterizedTypeReference<T> responseClazz,
                                                 Object... uriVariables)
            throws ServiceClientException {
        return callEndpointAuthorizedImpl(endpoint, requestObject, responseClazz, false, uriVariables);
    }

    public <T> ResponseEntity<T> callEndpointAuthorized(ServiceEndpoint endpoint,
                                                        ParameterizedTypeReference<T> responseClazz)
            throws ServiceClientException {
        return callEndpointAuthorizedImpl(endpoint, null, responseClazz, true, null);
    }

    public <T, R> ResponseEntity<T> callEndpointAuthorized(ServiceEndpoint endpoint,
                                                           R requestObject,
                                                           ParameterizedTypeReference<T> responseClazz) throws
            ServiceClientException {
        return callEndpointAuthorizedImpl(endpoint, requestObject, responseClazz, true, null);
    }

    public <T> ResponseEntity<T> callEndpointAuthorized(ServiceEndpoint endpoint,
                                                        ParameterizedTypeReference<T> responseClazz,
                                                        Object... uriVariables) throws ServiceClientException {
        return callEndpointAuthorizedImpl(endpoint, null, responseClazz, true, uriVariables);
    }

    /**
     * Makes a service call to a REST API endpoint using the RestClient exchange method. Will include an HTTP
     * Authorization header with JWT token, generated by the ClientTokenManager, if useAuth is set to true.
     *
     * @param endpoint      the REST endpoint to call (consisting of URL and HttpMethod)
     * @param requestObject (optional) object to send in request, can be null if there is none
     * @param responseClazz the class that the response conforms to
     * @param useAuth       true to include JWT token in the authorization http header, false to exclude
     * @param uriVariables  any uri variables to substitute in the endpoint URL
     * @param <T>           the type of the response object returned by the service call and thus the method. can be
     *                      void.
     * @return an object of type T returned by the service call
     * @throws ServiceClientException if there is an exception when calling the service
     */
    protected <T, R> ResponseEntity<T> callEndpointAuthorizedImpl(@NotNull ServiceEndpoint endpoint,
                                                                  R requestObject,
                                                                  @NotNull ParameterizedTypeReference<T> responseClazz,
                                                                  boolean useAuth,
                                                                  Object... uriVariables) throws
            ServiceClientException {

        // Check provided parameters, fill in defaults for null values, or throw exception if required.
        if (endpoint == null || endpoint.getCompleteUrl().isEmpty())
            throw new IllegalArgumentException(
                    "Provided ServiceEndpoint was null or the URL was empty. Cannot call service.");
        log.info("*** BEGIN ServiceClient REST API Call ***");
        log.info(String.format("Endpoint: '%s'", endpoint.getCompleteUrl()));
        log.info(String.format("Request Type: '%s'", endpoint.getHttpMethod().toString()));
        log.info(String.format("URI Variables: %s", uriVariables == null ? "null" : Arrays.toString(uriVariables)));
        if (uriVariables == null)
            uriVariables = new Object[]{};


        // Create HTTP Headers to attach with request
        String jwtToken = "";
        if (useAuth) {
            jwtToken = tokenManager.getToken();
            if (jwtToken == null || jwtToken.isEmpty())
                log.warn("Attempted to include JWT token, but JWT token generation failed.");
        }
        log.info(String.format("JWT Token: '%s'", jwtToken.isEmpty() ? "None" : jwtToken));
        HttpHeaders headers = createHttpHeaders(jwtToken);

        // Create Request Body (previously HttpEntity<Object>)
        HttpEntity<?> requestEntity = null;
        if (requestObject == null)
            requestEntity = new HttpEntity("", headers);
        else
            requestEntity = new HttpEntity(requestObject, headers);
        log.info(String.format("Request Entity: %s", requestObject == null ? "null" : requestObject.toString()));


        // Call ServiceEndpoint
        ResponseEntity<T> response = null;
        try {
            response = restTemplate.exchange(endpoint.getCompleteUrl(),
                    endpoint.getHttpMethod(),
                    requestEntity,
                    responseClazz,
                    uriVariables);
        } catch (RestClientException ex) {
            throw new ServiceClientException(ex, endpoint, requestObject, jwtToken, uriVariables);
        }
        log.info(String.format("Response Code: %s", response.getStatusCode().toString()));
        log.info(String.format("Response Body: %s", response.getBody().toString()));
        log.info("*** END ServiceClient REST API Call ***");

        return response;
    }

    /**
     * Creates a ServiceEndpoint object based on the different pieces of the URL.
     *
     * @param baseUrl    the domain of the URL PROTOCOL://XXX.YYY.ZZZ:PPP
     * @param endpoint   the endpoint part of the URL /SVC/X/Y/Z
     * @param httpMethod the HttpMethod (GET, POST, PUT, DELETE, etc) to use when calling the endpoint
     * @return the created ServiceEndpoint object
     */
    protected ServiceEndpoint createServiceEndpoint(String baseUrl, String endpoint, HttpMethod httpMethod) {
        return new ServiceEndpoint(baseUrl, endpoint, httpMethod);
    }

    /**
     * Creates HttpHeaders for making a Gateway service call, including a JWT authentication token.
     *
     * @param jwtAuthenticationToken a valid JWT authentication token allowing the service to be called
     * @return an HttpHeaders object to include in the request
     */
    protected HttpHeaders createHttpHeaders(String jwtAuthenticationToken) {
        HttpHeaders headers = null;
        try {
            headers = new HttpHeaders();
            // Only add the Authorization header if we have a token.
            if (jwtAuthenticationToken != null && !jwtAuthenticationToken.isEmpty()) {
                String authHeader = "Bearer " + jwtAuthenticationToken;
                headers.set(HttpHeaders.AUTHORIZATION, authHeader);
            }
        } catch (Exception ex) {
            log.error("An exception occurred creating HTTP headers in ServiceClient createHttpHeaders method. ", ex);
        }
        return headers;
    }

    protected RestTemplate getDefaultRestTemplate() {
        return new RestTemplate();
    }

    protected ClientTokenProvider getDefaultTokenProvider() {
        return new DefaultTokenProvider();
    }
}